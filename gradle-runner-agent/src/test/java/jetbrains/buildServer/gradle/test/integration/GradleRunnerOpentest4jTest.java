package jetbrains.buildServer.gradle.test.integration;

import java.text.ParseException;
import java.util.List;
import java.util.stream.Collectors;
import jetbrains.buildServer.messages.serviceMessages.TestFailed;
import org.jetbrains.annotations.NotNull;
import org.testng.annotations.Test;

import static jetbrains.buildServer.gradle.GradleRunnerConstants.GRADLE_RUNNER_ENHANCE_GRADLE_DAEMON_CLASSPATH;
import static org.testng.AssertJUnit.*;

public class GradleRunnerOpentest4jTest extends GradleRunnerServiceMessageTest {

  public static final String BUILD_CMD = "clean test";

  @Test(dataProvider = "gradle-version-provider>=8")
  public void should_ReportExpectedAndActualValues_When_StringValuesAreUsed(final String gradleVersion) throws Exception {
    // arrange
    String tests = " --tests OpenTest4jSimpleTextTest";
    final GradleRunConfiguration config = new GradleRunConfiguration(OPENTEST4J_PROJECT, BUILD_CMD + tests, null);
    config.setGradleVersion(gradleVersion);

    // act
    List<String> buildLog = run(config).getAllMessages();
    List<TestFailed> serviceMessages = getTestFailedServiceMessages(buildLog);

    // assert
    assertTrue(buildLog.stream().anyMatch(it -> it.equals("! The first action !")));
    assertEquals(1, serviceMessages.size());
    TestFailed serviceMessage = serviceMessages.get(0);
    assertEquals("TheActualValue", serviceMessage.getActual());
    assertEquals("TheExpectedValue", serviceMessage.getExpected());
  }

  @Test(dataProvider = "gradle-version-provider>=8")
  public void should_ReportExpectedAndActualValues_When_FileInfoClassesAreUsed(final String gradleVersion) throws Exception {
    // arrange
    String tests = " --tests OpenTest4jFileInfoTest";
    final GradleRunConfiguration config = new GradleRunConfiguration(OPENTEST4J_PROJECT, BUILD_CMD + tests, null);
    config.setGradleVersion(gradleVersion);

    // act
    List<String> buildLog = run(config).getAllMessages();
    List<TestFailed> serviceMessages = getTestFailedServiceMessages(buildLog);

    // assert
    assertTrue(buildLog.stream().anyMatch(it -> it.equals("! The first action !")));
    assertEquals(1, serviceMessages.size());
    TestFailed serviceMessage = serviceMessages.get(0);
    assertEquals("xxxxy", serviceMessage.getActual());
    assertEquals("xxxxx", serviceMessage.getExpected());
  }

  @Test(dataProvider = "gradle-version-provider>=8")
  public void should_NotReportExpectedAndActualValues_When_GradleDaemonEnhancementIsDisabled(final String gradleVersion) throws Exception {
    // arrange
    String tests = " --tests OpenTest4jFileInfoTest";
    myTeamCityConfigParameters.put(GRADLE_RUNNER_ENHANCE_GRADLE_DAEMON_CLASSPATH, "false");
    final GradleRunConfiguration config = new GradleRunConfiguration(OPENTEST4J_PROJECT, BUILD_CMD + tests, null);
    config.setGradleVersion(gradleVersion);

    // act
    List<String> buildLog = run(config).getAllMessages();
    List<TestFailed> serviceMessages = getTestFailedServiceMessages(buildLog);

    // assert
    assertEquals(1, serviceMessages.size());
    TestFailed serviceMessage = serviceMessages.get(0);
    assertNull(serviceMessage.getActual());
    assertNull(serviceMessage.getExpected());
  }

  @NotNull
  private List<TestFailed> getTestFailedServiceMessages(@NotNull List<String> buildLog) {
    return buildLog.stream()
                   .filter(it -> it.startsWith("##teamcity[testFailed"))
                   .map(text -> {
                     try {
                       return (TestFailed)TestFailed.parse(text);
                     } catch (ParseException e) {
                       throw new RuntimeException(e);
                     }
                   })
                   .collect(Collectors.toList());
  }
}

