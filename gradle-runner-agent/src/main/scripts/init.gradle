import jetbrains.buildServer.ComparisonFailureData
import jetbrains.buildServer.ComparisonFailureUtil
import jetbrains.buildServer.agent.AgentRuntimeProperties
import jetbrains.buildServer.gradle.GradleRunnerConstants
import jetbrains.buildServer.gradle.GradleBuildProblem
import jetbrains.buildServer.messages.serviceMessages.*

import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.atomic.AtomicReference

/*
* Copyright 2000-2020 JetBrains s.r.o.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

initscript {
  dependencies {
    def teamCityInitLib = System.getenv("TEAMCITY_BUILD_INIT_PATH")
    logger.info "Init lib: ${teamCityInitLib}"
    def classPathFiles = teamCityInitLib.split(File.pathSeparator)
    classpath files(classPathFiles)
  }
}

public class DependencyBasedTestRun {

  def logger

  public DependencyBasedTestRun(Logger logger) {
    this.logger = logger
  }

  public def configureGradle(Gradle gradle) {
    def rootProject = gradle.rootProject
    def incrementalOption = System.getenv(GradleRunnerConstants.ENV_INCREMENTAL_PARAM);
    logger.debug("Received following incremental setting: ${incrementalOption}")

    switch(incrementalOption) {
      case GradleRunnerConstants.ENV_INCREMENTAL_VALUE_SKIP:
        logger.debug("Incremental building is enabled, but full rebuild is forced");
        gradle.startParameter.taskNames = ["build"];
        break;

      case GradleRunnerConstants.ENV_INCREMENTAL_VALUE_PROCEED:
        logger.debug("Will look for affected projects")
        def modifiedProjects = findAffectedProjects(rootProject);
        if (modifiedProjects.empty) {
          logger.debug("No affected projects found. Running full build.")
          gradle.startParameter.taskNames = ["build"]
        } else {
          gradle.startParameter.taskNames = modifiedProjects.collect { it + ":buildDependents" }
          logger.debug("Will start with following tasks: ${gradle.startParameter.taskNames}")
        }
        break;

      default:
        logger.debug("Incremental building is not enabled");
    }
  }


  private def findAffectedProjects(Project project) {

    if (project.teamcity.containsKey(AgentRuntimeProperties.CHANGED_FILES_FILE_PARAM)) {
      def changedFiles = readChangedFiles(project.teamcity);
      def sourceSetsToProject = readSourceSets(project);

      logger.debug("Modified Files: ${changedFiles}")
      logger.debug("SourceSets to Project: ${sourceSetsToProject}")

      def changedProjects = []
      changedFiles.each { path ->
        sourceSetsToProject.findAll({
          path.startsWith(it.key)
        }).collect(changedProjects) {it.value}
      }

      logger.debug("Changes detected in following projects:")
      logger.debug("${changedProjects}")

      return changedProjects
    }
  }

  private def readSourceSets(Project proj) {
    def result = [:]
    proj.allprojects {
      def collectRelativePath = { File file ->
        def path = proj.relativePath(file.getAbsolutePath()).replace('\\','/')
        result[path] = project.getPath()
      }
      if (delegate.hasProperty("sourceSets")) {
        sourceSets*.allSource.srcDirs*.each collectRelativePath
        sourceSets*.resources.srcDirs*.each collectRelativePath
      }
    }
    return result
  }

  private def readChangedFiles(Map TCProps) {
    String filename = TCProps[AgentRuntimeProperties.CHANGED_FILES_FILE_PARAM]

    def lines = new File(filename).readLines()
    def personalMatch = /(.*):(.*):<personal>/
    def allMatch = /(.*):(.*):(.*)/

    if (lines.any { it ==~ personalMatch }) {
      return lines.grep(~personalMatch).collect {
        (it =~ personalMatch)[0][1]
      }
    } else {
      return lines.collect {
        (it =~ allMatch)[0][1]
      }
    }
  }
}

public class TeamcityPropertiesListener implements ProjectEvaluationListener {

  AtomicBoolean initScriptStartReported = new AtomicBoolean(false);

  Logger logger;
  Closure doAfterEvaluate;

  public TeamcityPropertiesListener(Logger log, Closure doAfterEvaluate) {
    logger = log
    this.doAfterEvaluate = doAfterEvaluate
  }

  public void beforeEvaluate(Project project) {
    loadProps(project);
    // Marker for TeamCity listener that shows that init script started to execute successfully
    if (initScriptStartReported.compareAndSet(false, true)) {
      logger.lifecycle(GradleRunnerConstants.STARTING_TEAMCITY_BUILD_PREFIX + project.teamcity["build.number"])
    }
  }

  public void afterEvaluate(Project project, ProjectState projectState) {
    if (project.hasProperty("teamcity") && doAfterEvaluate != null) {
      doAfterEvaluate(project)
    }
  }

  static Properties getProps(Project project, Logger logger, String file) {
    File propsFile = project.file(file)
    Properties props = new Properties()
    InputStream input

    try {
      input = new FileInputStream(propsFile)
      props.load(input)
    } catch (FileNotFoundException e) {
      logger.error(e.getMessage(), e)
    } catch (IOException e) {
      logger.error(e.getMessage(), e)
    } finally {
      try {
        input?.close()
      } catch (IOException e) {
        Logger.log(LogLevel.ERROR, "Failed to close file stream!", e)
      }
    }
    return props
  }

  private void loadProps(Project p) {
    String propsFilePath = System.getProperty(AgentRuntimeProperties.AGENT_BUILD_PARAMS_FILE_PROP);
    if (null == propsFilePath) {
      propsFilePath = System.getenv(AgentRuntimeProperties.AGENT_BUILD_PARAMS_FILE_ENV);
    }

    if (null != propsFilePath) {
      Properties props = getProps(p, logger, propsFilePath)
      addCustomProperties(p, props)
    } else {
      addCustomProperties(p, new HashMap())
    }
  }

  private void addCustomProperties(Project p, Map props) {
    if (p.hasProperty("ext")) {
      props.each { k,v -> p.ext.set(k, v)}
      p.ext.teamcity = props
    } else {
      p.setProperty("teamcity", props)
    }
  }
}

public class TeamcityTaskListener implements TaskExecutionListener, TaskActionListener {
  public static final String DEFAULT_FLOW_ID_PREFIX = "%%teamcity%%-"

  def taskMessages = new ConcurrentHashMap<Task, TeamCityOutputListener>()
  def blockOpenMessagesCache = new ConcurrentHashMap<Task, ServiceMessage>()
  def logger
  boolean isParallelExec
  def flowIdPrefix = DEFAULT_FLOW_ID_PREFIX;

  public TeamcityTaskListener(Logger log, boolean parallelExec) {
    logger = log;
    isParallelExec = parallelExec;
  }

  String getProjectFlowId(project) {
    return String.valueOf(project.getPath().hashCode());
  }

  public void beforeExecute(Task task) {
    ServiceMessage message;
    if (task instanceof AbstractCompile) {
      TeamCityOutputListener errorListener = taskMessages.get(task);
      if (null == errorListener) {
        // during the tasks execution service messages generated by us can be caught by TeamCityOutputListener
        // to prevent this we add flowIdPrefix to their flowId attribute and this allows TeamCityOutputListener class to exclude them
        errorListener = new TeamCityOutputListener("flowId='" + flowIdPrefix);
        taskMessages.put(task, errorListener);
      }
      errorListener.reset();
      task.getLogging().addStandardOutputListener(errorListener);
      task.getLogging().addStandardErrorListener(errorListener);
      message = addFlowId(task, new CompilationStarted(task.getPath()));
    } else {
      message = addFlowId(task, new BlockOpened(task.getPath()));
    }

    def oldMessage = popFromBlockOpenCache(task)
    if (oldMessage != null) {
      logger.debug("Unexpected BlockOpen message cache content: key=[${task.getPath()}] value=[${oldMessage}]");
      logger.lifecycle(message.asString());
    }
    logger.debug("BeforeExecute: storing message: key=[${task.getPath()}] value=[${message.asString().substring(2)}]");
    blockOpenMessagesCache.put(task, message);
  }


  public void afterExecute(Task task, TaskState taskState) {
    try {
      if (handleTaskSkippedState(task, taskState)) {
        return;
      }

      handleTaskFinishedState(task, taskState)
    } finally {
      taskMessages.remove(task);
    }
  }

  private void handleTaskFinishedState(Task task, TaskState taskState) {
    ServiceMessage blockCloseMessage;
    if (task instanceof AbstractCompile) {
      Throwable failure = taskState.getFailure();
      if (null != failure) {
        final TeamCityOutputListener outputListener = taskMessages.get(task);
        outputListener.getMessages().each { message ->
          logger.lifecycle(addFlowId(task, new Message(message, "ERROR", null)).asString()); // compilation failure
        }
      }
      blockCloseMessage = addFlowId(task, new CompilationFinished(task.getPath()));
    } else {
      blockCloseMessage = addFlowId(task, new BlockClosed(task.getPath()));
    }
    logger.lifecycle(blockCloseMessage.asString());
  }

  /**
   * Handle possible task up-to-date skip.
   * Checks if task was skipped. If so, reposts sequence of BlockOpened-BlockClosed messages with proper text
   * Otherwise, prints BlockOpened message, if it was not printed yet.
   * @param task
   * @param taskState
   * @return true if task was skipped.
   */
  private boolean handleTaskSkippedState(Task task, TaskState taskState) {
    def message = popFromBlockOpenCache(task);
    def skipped = false;
    if (message != null) {
      if (taskState.getSkipped()) {
        logger.debug("No actions were executed for task [${task}]. Task was skipped because [${taskState.getSkipMessage()}].")
        def text;

        if (message instanceof CompilationStarted) {
          text = ((CompilationStarted)message).getCompilerName();
        } else {
          text = ((BlockOpened)message).getBlockName();
        }

        text += " ${taskState.getSkipMessage()}";

        if (message instanceof CompilationStarted) {
          logger.lifecycle(addFlowId(task, new CompilationStarted(text)).asString());
          logger.lifecycle(addFlowId(task, new CompilationFinished(text)).asString());
        } else {
          logger.lifecycle(addFlowId(task, new BlockOpened(text)).asString());
          logger.lifecycle(addFlowId(task, new BlockClosed(text)).asString());
        }

        skipped = true;
      } else {
        logger.debug("No actions were executed for task [${task}]. But task was not skipped, sending blockOpenmessage [${message.asString().substring(2)}]")
        logger.lifecycle(message.asString())
      }
    }
    skipped
  }

  private ServiceMessage popFromBlockOpenCache(Task task) {
    ServiceMessage message = blockOpenMessagesCache.get(task);
    blockOpenMessagesCache.remove(task);
    return message
  }

  void beforeActions(final Task task) {
    ServiceMessage message = popFromBlockOpenCache(task);
    if (message != null) {
      logger.debug("BeforeActions: task [${task}]. Sending blockOpen message [${message.asString().substring(2)}]")
      logger.lifecycle(message.asString());
    } else {
      logger.debug("BeforeActions: null message for task [${task}]. Will not send service message")
    }
  }

  void afterActions(final Task task) {
    // do nothing
  }

  ServiceMessage addFlowId(task, message) {
    if (isParallelExec) {
      message.setFlowId(flowIdPrefix + String.valueOf(task.getPath().hashCode()))
    }
    return message
  }

  private class TeamCityOutputListener implements StandardOutputListener {
    private volatile StringBuffer text = new StringBuffer()
    private String ignoreMarker

    TeamCityOutputListener(final String ignoreMarker) {
      this.ignoreMarker = ignoreMarker
    }

    public void onOutput(CharSequence chars) {
      def str = chars.toString();
      if (str.contains(ignoreMarker)) return;
      text.append(str)
    }

    public Collection<String> getMessages() {
      def lines = text.toString().split('\\r?\\n');
      def res = []
      for (line in lines) {
        def trimmed = line.trim();
        if (trimmed.length() > 0) {
          res.add(line);
        }
      }
      return res;
    }

    public void reset() {
      text = new StringBuffer()
    }
  }

}

public class TeamcityTestListener {
  private static final int MAX_MESSAGE_SIZE = Integer.getInteger("teamcity.gradle.stacktrace.maxLength", 18 * 1024)
  private static final int MAX_TEST_NAME_LENGTH = Integer.getInteger("teamcity.gradle.testName.maxLength", 100)
  private static final int MIN_ATTACHED_MESSAGE_SIZE = Integer.getInteger("teamcity.gradle.minAttachedTestException", MAX_MESSAGE_SIZE)
  Logger logger
  def baseTask
  boolean isParallelBuild
  private String projectFlowId
  private ConcurrentMap<TestDescriptor, List> testOutputs = new ConcurrentHashMap()
  private Map<String, Boolean> startedFlowIds = new ConcurrentHashMap();

  boolean skipStdErr = false
  boolean skipStdOut = false
  TestNameDescriptor testNameDescriptor
  private final Project project
  private final AtomicLong testCounter;

  public TeamcityTestListener(Logger log, TestTaskWrapper task, boolean isParallel, Project project, AtomicLong testCounter, TestNameDescriptor testNameDescriptor) {
    this.project = project
    logger = log
    isParallelBuild = isParallel
    projectFlowId = TeamcityTaskListener.DEFAULT_FLOW_ID_PREFIX + String.valueOf(task.project.getPath().hashCode())
    this.testCounter = testCounter
    this.testNameDescriptor = testNameDescriptor
  }

  /**
   * Called before a test suite is started.
   * @param suite The suite whose tests are about to be executed.
   */
  public void beforeSuite(TestDescriptorWrapper suite) {
    if (suite.parent == null) return

    if (shouldBeIgnored(suite)) return

    String flowId = suite.getFlowId(projectFlowId)
    startFlowIfNotStarted(flowId, suite)

    ServiceMessage msg = new TestSuiteStarted(suite.name)
    msg.setFlowId(flowId)
    logger.lifecycle(msg.asString())
  }

  private boolean shouldBeIgnored(TestDescriptorWrapper suite) {
    suite.name.startsWith("Gradle Test Executor") || suite.name.startsWith("Gradle Test Run")
  }

  private void startFlowIfNotStarted(String flowId, TestDescriptorWrapper suite) {
    if (startedFlowIds.put(flowId, true) == null) {
      def parentFlowId = projectFlowId;
      def parentSuite = suite.parent
      if (parentSuite != null && !shouldBeIgnored(parentSuite)) {
        parentFlowId = parentSuite.getFlowId(projectFlowId)
      }

      logger.lifecycle(new ServiceMessage("flowStarted", ["flowId": flowId, "parent": parentFlowId]).asString())
    }
  }

  /**
   * Called after a test suite is finished.
   * @param suite The suite whose tests have finished being executed.
   * @param result The aggregate result for the suite.
   */
  public void afterSuite(TestDescriptorWrapper suite, TestResult result) {
    if (suite.parent == null) return;

    if (shouldBeIgnored(suite)) return;

    String flowId = suite.getFlowId(projectFlowId);
    ServiceMessage msg = new TestSuiteFinished(suite.name);
    msg.setFlowId(flowId);
    logger.lifecycle(msg.asString());

    finishStartedFlow(flowId);
  }

  private void finishStartedFlow(String flowId) {
    if (startedFlowIds.remove(flowId) != null) {
      logger.lifecycle(new ServiceMessage("flowFinished", ["flowId": flowId]).asString())
    }
  }

  /**
   * Called before a test is started.
   * @param test The test which is about to be executed.
   */
  public void beforeTest(TestDescriptorWrapper test) {
    String flowId = test.getFlowId(projectFlowId)
    startFlowIfNotStarted(flowId, test)

    ServiceMessage msg = new TestStarted(test.testName, false, null)
    msg.setFlowId(flowId)
    logger.lifecycle(msg.asString())
  }

  /**
   * Called after a test is finished.
   * @param test The test which has finished executing.
   * @param result The test result.
   */
  public void afterTest(TestDescriptorWrapper test, TestResult result) {
    String testName = test.testName
    String flowId = test.getFlowId(projectFlowId)

    def outputs = testOutputs.remove(test.descriptor);
    if (outputs != null) {
      synchronized (outputs) {
        flushOutputs(test, outputs)
      }
    }

    ServiceMessage msg;
    switch (result.getResultType()) {
      case org.gradle.api.tasks.testing.TestResult.ResultType.FAILURE:
        WrappedException exception = new WrappedException(result.getException(), MAX_MESSAGE_SIZE)
        msg = exception.getServiceMessage(testName)
        attacheBigFailTestMessage(testName, exception, flowId);

        msg.setFlowId(flowId);
        logger.lifecycle(msg.asString());
        break;
      case org.gradle.api.tasks.testing.TestResult.ResultType.SKIPPED:
        msg = new TestIgnored(testName, "");
        msg.setFlowId(flowId);
        logger.lifecycle(msg.asString());
        break;
    };

    final int duration = (int) (result.getEndTime() - result.getStartTime());
    msg = new TestFinished(testName, duration);
    msg.setFlowId(flowId);
    logger.lifecycle(msg.asString());

    finishStartedFlow(flowId);
  }

  private String getProjectProperty(String propertyName) {
    if (project.hasProperty("ext")) {
      return project.ext.teamcity[propertyName]
    } else {
      return project.property(propertyName)
    }
  }

  private setProjectProperty(String propertyName, String propertyValue) {
    if (project.hasProperty("ext")) {
      project.ext.teamcity[propertyName] = propertyValue
    } else {
      Map props = project.property("teamcity")
      props[propertyName] = propertyValue

      project.setProperty("teamcity", props)
    }
  }

  synchronized private File createBigStacktracesDir() {
    String path = null;
    if ((path = getProjectProperty("teamcity.build.stacktraceLogDir")) != null) {
      return new File(path)
    }

    final String rootTmpDirectory = getProjectProperty(AgentRuntimeProperties.BUILD_TEMP_DIR) ?: project.getBuildDir().path
    File resultDir = new File("${rootTmpDirectory}${File.separator}.teamcity${File.separator}testFailMessages${File.separator}${System.nanoTime()}")
    if (resultDir.mkdirs()) {
      setProjectProperty("teamcity.build.stacktraceLogDir", resultDir.path)
      return resultDir
    }
    return null
  }

  private void attacheBigFailTestMessage(String testName, WrappedException exception, String flowId) {
    if (MIN_ATTACHED_MESSAGE_SIZE == -1) return
    if (MIN_ATTACHED_MESSAGE_SIZE > exception.size) return
    if (exception.equalsOrigin) return

    File artifactDir = createBigStacktracesDir()
    if (artifactDir == null) {
      return
    }
    String fileName = "${testCounter.incrementAndGet()}.log"
    File artifactPath = new File(fileName, artifactDir)

    PrintStream logFilePrint
    try {
      artifactPath.delete()
      logFilePrint = new PrintStream(new FileOutputStream(artifactPath))
      exception.th.printStackTrace(logFilePrint)
    } finally {
      logFilePrint?.close()
    }

    String artifactName = ".teamcity/gradle/${artifactDir.name}"
    def artifact = new PublishArtifacts("${artifactPath.canonicalPath} => ${artifactName}")
    artifact.setFlowId(flowId)
    logger.lifecycle(artifact.toString())

    ServiceMessage metadata = new ServiceMessage(ServiceMessageTypes.TEST_METADATA, [testName: testName,
                                                                                     type    : 'artifact',
                                                                                     value   : "${artifactName}/${fileName}" as String,
                                                                                     name    : 'teamcity.test.output'])
    metadata.setFlowId(flowId)
    logger.lifecycle(metadata.toString())
  }

  public void onOutput(TestDescriptorWrapper test, outputEvent) {
    if (test.className == null) {
      // this is not a real test output
      return;
    }

    def outputs = testOutputs[test.descriptor];
    if (outputs == null) {
      outputs = [];
      def prev = testOutputs.putIfAbsent(test.descriptor, outputs)
      if (prev != null) {
        outputs = prev
      }
    }

    synchronized (outputs) {
      outputs.add(outputEvent);

      if (outputs.size() > 100) {
        flushOutputs(test, outputs)
        outputs.clear();
      }
    }
  }

  private void flushOutputs(TestDescriptorWrapper descriptor, List outputs) {
    String testName = descriptor.testName
    String flowId = descriptor.getFlowId(projectFlowId)

    StringBuilder stdout = new StringBuilder()
    StringBuilder stderr = new StringBuilder()

    for (oe in outputs) {
      switch (oe.getDestination()) {
        case TestOutputEvent.Destination.StdErr:
          if (!skipStdErr) stderr.append(oe.message)
          break
        case TestOutputEvent.Destination.StdOut:
          if (!skipStdOut) stdout.append(oe.message)
          break
      }
    }

    if (stdout.length() > 0) {
      def msg = new TestStdOut(testName, stdout.toString() - ~/\r?\n\z/)
      msg.addTag(ServiceMessage.PARSE_SERVICE_MESSAGES_INSIDE_TAG)
      msg.setFlowId(flowId)
      logger.lifecycle(msg.asString())
    }

    if (stderr.length() > 0) {
      def msg = new TestStdErr(testName, stderr.toString() - ~/\r?\n\z/)
      msg.addTag(ServiceMessage.PARSE_SERVICE_MESSAGES_INSIDE_TAG)
      msg.setFlowId(flowId)
      logger.lifecycle(msg.asString())
    }
  }

  def testListenerDelegate = [
          beforeSuite: { suite ->
            this.beforeSuite(new TestDescriptorWrapper(suite, testNameDescriptor))
          },

          afterSuite: { suite, result ->
            this.afterSuite(new TestDescriptorWrapper(suite, testNameDescriptor), result)
          },

          beforeTest: { testDescriptor ->
            this.beforeTest(new TestDescriptorWrapper(testDescriptor, testNameDescriptor))
          },

          afterTest: { testDescriptor, result ->
            this.afterTest(new TestDescriptorWrapper(testDescriptor, testNameDescriptor), result)
          }]

  def testOutputDelegate = [
          onOutput: { testDescriptor, outputEvent ->
            this.onOutput(new TestDescriptorWrapper(testDescriptor, testNameDescriptor), outputEvent)
          }]

}

public enum TestNameDescriptor {
  DEFAULT {
    String getTestName(TestDescriptorWrapper descriptor) {
      return DISPLAY_NAME.getTestName(descriptor)
    }
  },
  NAME {
    String getTestName(TestDescriptorWrapper descriptor) {
      return super.getTestName(descriptor)
    }
  },
  DISPLAY_NAME {
    String getTestName(TestDescriptorWrapper descriptor) {
      String methodName = getMethodName(descriptor.name)
      if (descriptor.displayName.startsWith(methodName)) {
        methodName = descriptor.displayName
      } else {
        methodName = "$methodName(${descriptor.displayName})"
      }
      if (methodName == "${descriptor.name}()") {
        methodName = descriptor.name
      }
      return "${descriptor.className}.$methodName"
    }

    private final List<Character> BRACKETS = [(char)'(', (char)'[', (char)'{', (char)'<']

    private String getMethodName(String name) {
      for (int i = 0; i < name.length(); i++) {
        if (name.charAt(i) in BRACKETS) return name.substring(0, i)
      }
      return name
    }
  }

  public String getTestName(TestDescriptorWrapper descriptor) {
    "${descriptor.className}.${descriptor.name}"
  }

  static TestNameDescriptor of(String param) {
    if (param == null) return DEFAULT
    switch (param) {
      case "name": return NAME
      case "displayName": return DISPLAY_NAME
      default: return DEFAULT
    }
  }
}

public class TestDescriptorWrapper {
  final TestNameDescriptor testNameDescriptor
  final TestDescriptor descriptor

  TestDescriptorWrapper(TestDescriptor descriptor, TestNameDescriptor testNameDescriptor) {
    this.descriptor = descriptor
    this.testNameDescriptor = testNameDescriptor
  }

  String getTestName() {
    testNameDescriptor?.getTestName(this) ?: TestNameDescriptor.DEFAULT.getTestName(this)
  }

  String getClassName() {
    return descriptor.getClassName()
  }

  String getName() {
    return descriptor.getName()
  }

  TestDescriptorWrapper getParent() {
    def parent = descriptor.parent
    if (parent != null) return new TestDescriptorWrapper(parent, testNameDescriptor)
    return null
  }

  String getClassDisplayName() {
    if(descriptor.metaClass.respondsTo(descriptor, "getClassDisplayName")) {
      return descriptor.getClassDisplayName() ?: descriptor.getClassName()
    }
    return descriptor.getClassName()
  }

  String getDisplayName() {
    if(descriptor.metaClass.respondsTo(descriptor, "getDisplayName")) {
      return descriptor.getDisplayName() ?: descriptor.getName()
    }
    return descriptor.getName()
  }

  String getFlowId(String parentFlowId) {
    "$parentFlowId-${System.identityHashCode(descriptor)}"
  }
}

public class TeamcityRerunTestsListener extends  BuildAdapter {
  Logger logger
  AtomicReference<Properties> config;
  boolean defaultOption = false;
  boolean newOption = false;

  public TeamcityRerunTestsListener(Logger log, AtomicReference<Properties> tcConfigurationParameters) {
    logger = log
    config = tcConfigurationParameters
  }

  @Override
  void projectsEvaluated(Gradle gradle) {
    def envOption = System.getenv(GradleRunnerConstants.ENV_SUPPORT_TEST_RETRY)
    envOption = envOption == null ? "false" : envOption
    defaultOption = envOption.toBoolean()
    if (defaultOption == true) return
    def conf = config.get()
    if (conf != null && conf[GradleRunnerConstants.GRADLE_USE_TEST_RETRY_PLUGIN] == "false") return

    gradle.taskGraph.whenReady { graph ->
      for (Task task : graph.allTasks) {
        if (!TestTaskWrapper.type.isAssignableFrom(task.class)) continue
        if (!task.project.plugins.hasPlugin("org.gradle.test-retry")) continue
        def wrapper = new TestTaskWrapper(task)
        def plugin = wrapper.getExtensions()?.findByName("retry")
        if (plugin == null) continue
        if (!plugin.metaClass.respondsTo(plugin, "getMaxRetries")) continue
        def retries = plugin.getMaxRetries()
        if (!retries.metaClass.respondsTo(retries, "getOrNull")) continue
        if (retries.getOrNull() ?: 0 > 0) {
          newOption = true
          logger.lifecycle(new ServiceMessage("testRetrySupport", ["enabled": "true"]).asString())
          break
        }
      }
    }
  }

  @Override
  void buildFinished(BuildResult result) {
    if (defaultOption == true || defaultOption == newOption) return
    logger.lifecycle(new ServiceMessage("testRetrySupport", ["enabled": defaultOption.toString()]).asString())
  }
}

public class TeamcityExceptionsListener extends BuildAdapter {
  def logger

  public TeamcityExceptionsListener(Logger log) {
    logger = log
  }

  @Override
  void buildFinished(BuildResult result) {
    def failure = result.getFailure()
    if (failure != null) {
      while (!(failure instanceof org.gradle.api.tasks.TaskExecutionException) && failure != failure.getCause() && failure.getCause() != null) {
        failure = failure.getCause()
      }
      def message;
      if (failure instanceof org.gradle.api.tasks.TaskExecutionException && failure.getCause() != null) {
        message = "${failure.getMessage()} ${failure.getCause().getClass().getName()}: ${failure.getCause().getMessage()}"
      } else {
        message = "${failure.getClass().getName()}: ${failure.getMessage()}"
      }
      if (message.contains("There were failing tests") || message.contains("Compilation failed") || message.contains("Compilation error")) {
        // do not report tests and compilation failures as build problems, as they are logged separately
        return
      }
      logger.warn(new GradleBuildProblem(message).asString());
    }
  }
}

/**
 * Use WrappedException if you need to make a error message shorter
 */
class WrappedException extends Exception {
  final Throwable th
  private final int length
  private final String DELIMITER
  private final String message;

  /**
   * @param th     original exception
   * @param length max message length
   */
  WrappedException(Throwable th, int length) {
    this.th = th ?: new Exception() {
      @Override void printStackTrace(PrintWriter printWriter) { }
      @Override void printStackTrace(PrintStream ps) { }
      @Override void printStackTrace() { }
      @Override Throwable fillInStackTrace() { this }
      @Override StackTraceElement[] getStackTrace() { new StackTraceElement[0] }
      @Override String toString() { "" }
    }

    this.length = length
    int size = length / 1024
    DELIMITER = "***** A part of the stacktrace was cut by TeamCity build agent because the stacktrace size exceeded ${size} KB *****"
    message = trim(this.th.toString(), length)
  }

  public boolean isEqualsOrigin() {
    return size <= length
  }

  public int getSize() {
    return th.toString().length()
  }

  @Override
  public String toString() {
    return trim(th.toString(), length)
  }

  public ServiceMessage getServiceMessage(String testName) {
    if (th.toString() == "") return new TestFailed(testName, this);
    ComparisonFailureData cfd = ComparisonFailureUtil.extractComparisonFailure(th)
    if (cfd != null) {
      return new TestFailed(testName, this, trim(cfd.getActual(), length), trim(cfd.getExpected(), length));
    } else {
      return new TestFailed(testName, this);
    }
  }

  /**
   * Print StackTrace from the delegate object but a message from current current
   */
  @Override
  void printStackTrace(final PrintStream s) {
    Throwable exc = this;
    PrintStream stream = new PrintStream(s) {
      @Override
      void println(final Object obj) {
        super.println(th.is(obj) ? exc : obj)
      }
    }
    th.printStackTrace(stream)
  }

  /**
   * Split the message into 2 parts, if its size is large
   * @param str original message
   * @param length       max length
   * @return original message if str.length < length or split message with delimiter
   */
  private String trim(String str, int length) {
    if (str == null || str.length() <= length) return str

    return """${str.substring(0, (int)(length / 2))} ...

${DELIMITER}

... ${str.substring(str.length() - (int)(length / 2))}"""
  }
}

class TestTaskWrapper {
  final static Class type
  static {
    try {
      type = Class.forName("org.gradle.api.tasks.testing.AbstractTestTask")
    } catch (ClassNotFoundException ignore) {
      type = Test.class
    }
  }
  private final def testTask

  /**
   * Use {@link TestTaskWrapper#forAllTestTasks} to instantiate this object correctly.
   */
  private TestTaskWrapper(def testTask) { this.testTask = testTask }
  void addTestListener(def listener) { testTask.addTestListener(listener) }
  void addTestOutputListener(def listener) { testTask.addTestOutputListener(listener) }
  Project getProject() { testTask.project }
  TestTaskWrapper jvmArgs(Object... arguments) {
    if (testTask instanceof Test) {
      testTask.jvmArgs(arguments)
    }
    return this
  }

  TestTaskWrapper setTmpDirectory(String path) {
    if (testTask instanceof Test &&
        path != null && path != "") {
      testTask.systemProperty("java.io.tmpdir", path)
    }
    return this
  }

  def getExtensions() {
    if(testTask.metaClass.respondsTo(testTask, 'getExtensions')) {
      return testTask.extensions
    }
    return null
  }

  /**
   * Creates an instance of the {@link TestTaskWrapper} for every instance of the Test in the TaskCollection.
   * Attempts to lazily evaluate the Closure action against all instances lazily if the version of Gradle supports it.
   */
  static void forAllTestTasks(TaskCollection taskCollection, Closure action) {
    if (taskCollection.metaClass.respondsTo(taskCollection, 'configureEach')) {
      // Use lazy task configuration:
      // https://docs.gradle.org/current/userguide/task_configuration_avoidance.html
      taskCollection.configureEach { task ->
        TestTaskWrapper wrapper = new TestTaskWrapper(task)
        action(wrapper)
      }
    } else {
      // Fallback
      taskCollection.all { task ->
        TestTaskWrapper wrapper = new TestTaskWrapper(task)
        action(wrapper)
      }
    }
  }
}

def isParallelExec = (gradle.startParameter.hasProperty("parallelThreadCount") && gradle.startParameter.parallelThreadCount != 0) ||
                     (gradle.startParameter.hasProperty("parallelProjectExecutionEnabled") && gradle.startParameter.parallelProjectExecutionEnabled);
def testOutputListenerClass = null
try {
  testOutputListenerClass = Class.forName("org.gradle.api.tasks.testing.TestOutputListener", false, getClass().getClassLoader());
} catch (ClassNotFoundException e) {
  logger.debug("Could not load TestOutputListener class. Test output will not be available")
}

final AtomicLong testCounter = new AtomicLong(0);
final AtomicReference<Properties> tcConfigurationParameters = new AtomicReference<Properties>(new Properties())

gradle.addListener(new TeamcityPropertiesListener(logger, { project ->
  // init jvm args
  final String jvmargs = (String)project.teamcity["gradle.test.jvmargs"]
  final String[] arguments = jvmargs == null ? new String[0] : jvmargs.split("\n")
  TestTaskWrapper.forAllTestTasks(project.tasks.withType(TestTaskWrapper.type)) { TestTaskWrapper task ->
    task.setTmpDirectory(project.teamcity["teamcity.build.tempDir"]).jvmArgs(arguments)
  }
  // read teamcity configuration parameters
  String tcConfigFile = project.teamcity[AgentRuntimeProperties.AGENT_CONFIGURATION_PARAMS_FILE_PROP]
  if (tcConfigFile != null && new File(tcConfigFile).exists()) {
    tcConfigurationParameters.set(TeamcityPropertiesListener.getProps(project, logger, tcConfigFile))
  }
}))

gradle.addListener(new TeamcityExceptionsListener(logger))
gradle.addListener(new TeamcityRerunTestsListener(logger, tcConfigurationParameters))
gradle.useLogger(new TeamcityTaskListener(logger, isParallelExec))
gradle.projectsEvaluated { Gradle gradle ->
  new DependencyBasedTestRun(logger).configureGradle(gradle)
  gradle.rootProject.allprojects { Project project ->
    TestTaskWrapper.forAllTestTasks(project.tasks.withType(TestTaskWrapper.type)) { TestTaskWrapper testTask ->
      Properties tcConfigParams = tcConfigurationParameters.get()
      def descriptor = TestNameDescriptor.of(tcConfigParams[GradleRunnerConstants.GRADLE_TEST_NAME_FORMAT])

      def testListener = new TeamcityTestListener(logger, testTask, isParallelExec, project, testCounter, descriptor)
      testTask.addTestListener(testListener.testListenerDelegate as TestListener)
      if (testOutputListenerClass != null) {
        testTask.addTestOutputListener(testListener.testOutputDelegate.asType(testOutputListenerClass))
        testListener.skipStdOut = Boolean.valueOf(System.properties["teamcity.ignoreTestStdOut"])
        testListener.skipStdErr = Boolean.valueOf(System.properties["teamcity.ignoreTestStdErr"])
      }
    }
  }

  gradle.rootProject.allprojects.each { project ->
    project.getTasks().findByName("junitPlatformTest")?.outputs?.files?.each { file ->
      def message = new ServiceMessage("importData", ["type": "junit", "path": "$file.absolutePath/*.xml".toString()])
      println(message.asString())
    }
  }
}
