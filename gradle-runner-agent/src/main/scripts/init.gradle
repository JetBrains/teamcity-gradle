import jetbrains.buildServer.ComparisonFailureData
import jetbrains.buildServer.ComparisonFailureUtil
import jetbrains.buildServer.agent.AgentRuntimeProperties
import jetbrains.buildServer.gradle.GradleBuildProblem
import jetbrains.buildServer.gradle.GradleRunnerConstants
import jetbrains.buildServer.gradle.filter.GradleTestFilter
import jetbrains.buildServer.messages.serviceMessages.*

import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.atomic.AtomicReference
import java.util.regex.Pattern

/*
* Copyright 2000-2022 JetBrains s.r.o.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

initscript {
  dependencies {
    def teamCityInitLib = System.getenv("TEAMCITY_BUILD_INIT_PATH")
    logger.info "Init lib: ${teamCityInitLib}"
    def classPathFiles = teamCityInitLib.split(File.pathSeparator)
    classpath files(classPathFiles)
  }
}

public class DependencyBasedTestRun {

  def logger

  public DependencyBasedTestRun(Logger logger) {
    this.logger = logger
  }

  public def configureGradle(Gradle gradle) {
    def rootProject = gradle.rootProject
    def incrementalOption = System.getenv(GradleRunnerConstants.ENV_INCREMENTAL_PARAM);
    logger.debug("Received following incremental setting: ${incrementalOption}")

    switch(incrementalOption) {
      case GradleRunnerConstants.ENV_INCREMENTAL_VALUE_SKIP:
        logger.debug("Incremental building is enabled, but full rebuild is forced");
        gradle.startParameter.taskNames = ["build"];
        break;

      case GradleRunnerConstants.ENV_INCREMENTAL_VALUE_PROCEED:
        logger.debug("Will look for affected projects")
        def modifiedProjects = findAffectedProjects(rootProject);
        if (modifiedProjects.empty) {
          logger.debug("No affected projects found. Running full build.")
          gradle.startParameter.taskNames = ["build"]
        } else {
          gradle.startParameter.taskNames = modifiedProjects.collect { it + ":buildDependents" }
          logger.debug("Will start with following tasks: ${gradle.startParameter.taskNames}")
        }
        break;

      default:
        logger.debug("Incremental building is not enabled");
    }
  }


  private def findAffectedProjects(Project project) {

    if (project.teamcity.containsKey(AgentRuntimeProperties.CHANGED_FILES_FILE_PARAM)) {
      def changedFiles = readChangedFiles(project.teamcity);
      def sourceSetsToProject = readSourceSets(project);

      logger.debug("Modified Files: ${changedFiles}")
      logger.debug("SourceSets to Project: ${sourceSetsToProject}")

      def changedProjects = []
      changedFiles.each { path ->
        sourceSetsToProject.findAll({
          path.startsWith(it.key)
        }).collect(changedProjects) {it.value}
      }

      logger.debug("Changes detected in following projects:")
      logger.debug("${changedProjects}")

      return changedProjects
    }
  }

  private def readSourceSets(Project proj) {
    def result = [:]
    proj.allprojects {
      def collectRelativePath = { File file ->
        def path = proj.relativePath(file.getAbsolutePath()).replace('\\','/')
        result[path] = project.getPath()
      }
      if (delegate.hasProperty("sourceSets")) {
        sourceSets*.allSource.srcDirs*.each collectRelativePath
        sourceSets*.resources.srcDirs*.each collectRelativePath
      }
    }
    return result
  }

  private def readChangedFiles(Map TCProps) {
    String filename = TCProps[AgentRuntimeProperties.CHANGED_FILES_FILE_PARAM]

    def lines = new File(filename).readLines()
    def personalMatch = /(.*):(.*):<personal>/
    def allMatch = /(.*):(.*):(.*)/

    if (lines.any { it ==~ personalMatch }) {
      return lines.grep(~personalMatch).collect {
        (it =~ personalMatch)[0][1]
      }
    } else {
      return lines.collect {
        (it =~ allMatch)[0][1]
      }
    }
  }
}

public class TeamcityPropertiesListener implements ProjectEvaluationListener {

  AtomicBoolean initScriptStartReported = new AtomicBoolean(false);

  Logger logger;
  Closure doAfterEvaluate;

  public TeamcityPropertiesListener(Logger log, Closure doAfterEvaluate) {
    logger = log
    this.doAfterEvaluate = doAfterEvaluate
  }

  public void beforeEvaluate(Project project) {
    loadProps(project);
    // Marker for TeamCity listener that shows that init script started to execute successfully
    if (initScriptStartReported.compareAndSet(false, true)) {
      logger.lifecycle(GradleRunnerConstants.STARTING_TEAMCITY_BUILD_PREFIX + project.teamcity["build.number"])
    }
  }

  public void afterEvaluate(Project project, ProjectState projectState) {
    if (project.hasProperty("teamcity") && doAfterEvaluate != null) {
      doAfterEvaluate(project)
    }
  }

  static Properties getProps(Project project, Logger logger, String file) {
    File propsFile = project.file(file)
    Properties props = new Properties()
    InputStream input

    try {
      input = new FileInputStream(propsFile)
      props.load(input)
    } catch (FileNotFoundException e) {
      logger.error(e.getMessage(), e)
    } catch (IOException e) {
      logger.error(e.getMessage(), e)
    } finally {
      try {
        input?.close()
      } catch (IOException e) {
        Logger.log(LogLevel.ERROR, "Failed to close file stream!", e)
      }
    }
    return props
  }

  private void loadProps(Project p) {
    String propsFilePath = System.getProperty(AgentRuntimeProperties.AGENT_BUILD_PARAMS_FILE_PROP);
    if (null == propsFilePath) {
      propsFilePath = System.getenv(AgentRuntimeProperties.AGENT_BUILD_PARAMS_FILE_ENV);
    }

    if (null != propsFilePath) {
      Properties props = getProps(p, logger, propsFilePath)
      addCustomProperties(p, props)
    } else {
      addCustomProperties(p, new HashMap())
    }
  }

  private void addCustomProperties(Project p, Map props) {
    if (p.hasProperty("ext")) {
      props.each { k,v -> p.ext.set(k, v)}
      p.ext.teamcity = props
    } else {
      p.setProperty("teamcity", props)
    }
  }
}

public class TeamcityTaskListener implements TaskExecutionListener, TaskActionListener {
  public static final String DEFAULT_FLOW_ID_PREFIX = "%%teamcity%%-"

  def taskMessages = new ConcurrentHashMap<Task, TeamCityOutputListener>()
  def blockOpenMessagesCache = new ConcurrentHashMap<Task, ServiceMessage>()
  def logger
  boolean isParallelExec
  def flowIdPrefix = DEFAULT_FLOW_ID_PREFIX;

  public TeamcityTaskListener(Logger log, boolean parallelExec) {
    logger = log;
    isParallelExec = parallelExec;
  }

  String getProjectFlowId(project) {
    return String.valueOf(project.getPath().hashCode());
  }

  public void beforeExecute(Task task) {
    ServiceMessage message;
    if (task instanceof AbstractCompile) {
      TeamCityOutputListener errorListener = taskMessages.get(task);
      if (null == errorListener) {
        // during the tasks execution service messages generated by us can be caught by TeamCityOutputListener
        // to prevent this we add flowIdPrefix to their flowId attribute and this allows TeamCityOutputListener class to exclude them
        errorListener = new TeamCityOutputListener("flowId='" + flowIdPrefix);
        taskMessages.put(task, errorListener);
      }
      errorListener.reset();
      task.getLogging().addStandardOutputListener(errorListener);
      task.getLogging().addStandardErrorListener(errorListener);
      message = addFlowId(task, new CompilationStarted(task.getPath()));
    } else {
      message = addFlowId(task, new BlockOpened(task.getPath()));
    }

    def oldMessage = popFromBlockOpenCache(task)
    if (oldMessage != null) {
      logger.debug("Unexpected BlockOpen message cache content: key=[${task.getPath()}] value=[${oldMessage}]");
      logger.lifecycle(message.asString());
    }
    logger.debug("BeforeExecute: storing message: key=[${task.getPath()}] value=[${message.asString().substring(2)}]");
    blockOpenMessagesCache.put(task, message);
  }


  public void afterExecute(Task task, TaskState taskState) {
    try {
      if (handleTaskSkippedState(task, taskState)) {
        return;
      }

      handleTaskFinishedState(task, taskState)
    } finally {
      taskMessages.remove(task);
    }
  }

  private void handleTaskFinishedState(Task task, TaskState taskState) {
    ServiceMessage blockCloseMessage;
    if (task instanceof AbstractCompile) {
      Throwable failure = taskState.getFailure();
      if (null != failure) {
        final TeamCityOutputListener outputListener = taskMessages.get(task);
        outputListener.getMessages().each { message ->
          logger.lifecycle(addFlowId(task, new Message(message, "ERROR", null)).asString()); // compilation failure
        }
      }
      blockCloseMessage = addFlowId(task, new CompilationFinished(task.getPath()));
    } else {
      blockCloseMessage = addFlowId(task, new BlockClosed(task.getPath()));
    }
    logger.lifecycle(blockCloseMessage.asString());
  }

  /**
   * Handle possible task up-to-date skip.
   * Checks if task was skipped. If so, reposts sequence of BlockOpened-BlockClosed messages with proper text
   * Otherwise, prints BlockOpened message, if it was not printed yet.
   * @param task
   * @param taskState
   * @return true if task was skipped.
   */
  private boolean handleTaskSkippedState(Task task, TaskState taskState) {
    def message = popFromBlockOpenCache(task);
    def skipped = false;
    if (message != null) {
      if (taskState.getSkipped()) {
        logger.debug("No actions were executed for task [${task}]. Task was skipped because [${taskState.getSkipMessage()}].")
        def text;

        if (message instanceof CompilationStarted) {
          text = ((CompilationStarted)message).getCompilerName();
        } else {
          text = ((BlockOpened)message).getBlockName();
        }

        text += " ${taskState.getSkipMessage()}";

        if (message instanceof CompilationStarted) {
          logger.lifecycle(addFlowId(task, new CompilationStarted(text)).asString());
          logger.lifecycle(addFlowId(task, new CompilationFinished(text)).asString());
        } else {
          logger.lifecycle(addFlowId(task, new BlockOpened(text)).asString());
          logger.lifecycle(addFlowId(task, new BlockClosed(text)).asString());
        }

        skipped = true;
      } else {
        logger.debug("No actions were executed for task [${task}]. But task was not skipped, sending blockOpenmessage [${message.asString().substring(2)}]")
        logger.lifecycle(message.asString())
      }
    }
    skipped
  }

  private ServiceMessage popFromBlockOpenCache(Task task) {
    ServiceMessage message = blockOpenMessagesCache.get(task);
    blockOpenMessagesCache.remove(task);
    return message
  }

  void beforeActions(final Task task) {
    ServiceMessage message = popFromBlockOpenCache(task);
    if (message != null) {
      logger.debug("BeforeActions: task [${task}]. Sending blockOpen message [${message.asString().substring(2)}]")
      logger.lifecycle(message.asString());
    } else {
      logger.debug("BeforeActions: null message for task [${task}]. Will not send service message")
    }
  }

  void afterActions(final Task task) {
    // do nothing
  }

  ServiceMessage addFlowId(task, message) {
    if (isParallelExec) {
      message.setFlowId(flowIdPrefix + String.valueOf(task.getPath().hashCode()))
    }
    return message
  }

  private class TeamCityOutputListener implements StandardOutputListener {
    private volatile StringBuffer text = new StringBuffer()
    private String ignoreMarker

    TeamCityOutputListener(final String ignoreMarker) {
      this.ignoreMarker = ignoreMarker
    }

    public void onOutput(CharSequence chars) {
      def str = chars.toString();
      if (str.contains(ignoreMarker)) return;
      text.append(str)
    }

    public Collection<String> getMessages() {
      def lines = text.toString().split('\\r?\\n');
      def res = []
      for (line in lines) {
        def trimmed = line.trim();
        if (trimmed.length() > 0) {
          res.add(line);
        }
      }
      return res;
    }

    public void reset() {
      text = new StringBuffer()
    }
  }

}

public class TeamcityTestListener {
  private static final int MAX_TEST_NAME_LENGTH = Integer.getInteger("teamcity.gradle.testName.maxLength", 100)
  private final Logger logger
  private boolean isParallelBuild
  private final ConcurrentMap<TestDescriptorWrapper, List> testOutputs = new ConcurrentHashMap()
  private final FlowWrapper flow

  private boolean skipStdErr = false
  private boolean skipStdOut = false
  private final TestNameDescriptor testNameDescriptor
  private final ProjectPropertyStorage project
  private final AtomicLong testCounter;
  private final Pattern ignoredSuiteFormat

  public TeamcityTestListener(Logger log, TestTaskWrapper task, boolean isParallel, Project project, AtomicLong testCounter, TestNameDescriptor testNameDescriptor, String ignoredSuiteFormat) {
    this.project = new ProjectPropertyStorage(project)
    logger = log
    isParallelBuild = isParallel
    flow = new FlowWrapper(TeamcityTaskListener.DEFAULT_FLOW_ID_PREFIX + String.valueOf(task.project.getPath().hashCode()))
    this.testCounter = testCounter
    this.testNameDescriptor = testNameDescriptor
    this.ignoredSuiteFormat = ignoredSuiteFormat?.trim() ? Pattern.compile(ignoredSuiteFormat) : null
  }

  /**
   * Called before a test suite is started.
   * @param suite The suite whose tests are about to be executed.
   */
  public void beforeSuite(SuiteDescriptorWrapper suite) {
    suite.start { flow, msg ->
      if (flow != null) this.logger.lifecycle(flow.asString())
      this.logger.lifecycle(msg.asString())
    }
  }

  /**
   * Called after a test suite is finished.
   * @param suite The suite whose tests have finished being executed.
   * @param result The aggregate result for the suite.
   */
  public void afterSuite(SuiteDescriptorWrapper suite, TestResult result) {
    suite.finish { flow, msg ->
      this.logger.lifecycle(msg.asString());
      if (flow != null ) this.logger.lifecycle(flow.asString())
    }
  }

  /**
   * Called before a test is started.
   * @param test The test which is about to be executed.
   */
  public void beforeTest(TestDescriptorWrapper test) {
    test.start { flow, msg ->
      if (flow != null) this.logger.lifecycle(flow.asString())
      this.logger.lifecycle(msg.asString())
    }
  }

  /**
   * Called after a test is finished.
   * @param test The test which has finished executing.
   * @param result The test result.
   */
  public void afterTest(TestDescriptorWrapper test, TestResult result) {
    test.finish(result) { flow, msg ->
      test.flush(testOutputs.remove(test)) { out -> this.logger.lifecycle(out.asString()) }
      test.result(result, testCounter) { messages -> messages.each{ message -> this.logger.lifecycle(message.asString()) } }

      this.logger.lifecycle(msg.asString());
      if (flow != null) this.logger.lifecycle(flow.asString())
    }
  }

  public void onOutput(TestDescriptorWrapper test, def event) {
    if (test.ignored) {
      // this is not a real test output
      return
    }

    switch (event.destination) {
      case TestOutputEvent.Destination.StdErr:
        if (skipStdErr) return
        break
      case TestOutputEvent.Destination.StdOut:
        if (skipStdOut) return
        break
      default: return
    }

    List outputs = testOutputs[test];
    if (outputs == null) {
      outputs = [];
      def prev = testOutputs.putIfAbsent(test, outputs)
      if (prev != null) {
        outputs = prev
      }
    }

    synchronized (outputs) {
      outputs.add(event);

      if (outputs.size() > 100) {
        test.flush(outputs) { msg -> this.logger.lifecycle(msg.asString()) }
        outputs.clear();
      }
    }
  }

  def testListenerDelegate = [
          beforeSuite: { suite ->
            this.beforeSuite(new SuiteDescriptorWrapper(suite, flow, ignoredSuiteFormat))
          },

          afterSuite: { suite, result ->
            this.afterSuite(new SuiteDescriptorWrapper(suite, flow, ignoredSuiteFormat), result)
          },

          beforeTest: { test ->
            this.beforeTest(new TestDescriptorWrapper(test, testNameDescriptor, flow, this.project, ignoredSuiteFormat))
          },

          afterTest: { test, result ->
            this.afterTest(new TestDescriptorWrapper(test, testNameDescriptor, flow, this.project, ignoredSuiteFormat), result)
          }]

  def testOutputDelegate = [
          onOutput: { test, event ->
            this.onOutput(new TestDescriptorWrapper(test, testNameDescriptor, flow, this.project, ignoredSuiteFormat), event)
          }]

}

class ProjectPropertyStorage {
  private final Project project
  ProjectPropertyStorage(Project project) {
    this.project = project
  }

  String getAt(String name) {
    if (project.hasProperty("ext")) {
      return project.ext.teamcity[name]
    } else {
      return project.property(name)
    }
  }

  void putAt(String name, Object value) {
    if (project.hasProperty("ext")) {
      project.ext.teamcity[name] = value
    } else {
      Map props = project.property("teamcity")
      props[name] = value

      project.setProperty("teamcity", props)
    }
  }

  File getBuildDir() { project.buildDir }
}

public enum TestNameDescriptor {
  DEFAULT {
    String getTestName(TestDescriptorWrapper descriptor) {
      return DISPLAY_NAME.getTestName(descriptor)
    }
  },
  NAME {
    String getTestName(TestDescriptorWrapper descriptor) {
      return super.getTestName(descriptor)
    }
  },
  DISPLAY_NAME {
    String getTestName(TestDescriptorWrapper descriptor) {
      String methodName = getMethodName(descriptor.name)
      if (descriptor.displayName.startsWith(methodName)) {
        methodName = descriptor.displayName
      } else {
        methodName = "$methodName(${descriptor.displayName})"
      }
      if (methodName == "${descriptor.name}()") {
        methodName = descriptor.name
      }
      return "${descriptor.className}.$methodName"
    }

    private final List<Character> BRACKETS = [(char)'(', (char)'[', (char)'{', (char)'<']

    private String getMethodName(String name) {
      for (int i = 0; i < name.length(); i++) {
        if (name.charAt(i) in BRACKETS) return name.substring(0, i)
      }
      return name
    }
  }

  public String getTestName(TestDescriptorWrapper descriptor) {
    "${descriptor.className}.${descriptor.name}"
  }

  static TestNameDescriptor of(String param) {
    if (param == null) return DEFAULT
    switch (param) {
      case "name": return NAME
      case "displayName": return DISPLAY_NAME
      default: return DEFAULT
    }
  }
}

public class FlowWrapper {
  private final String project
  private Set<String> started = Collections.newSetFromMap(new ConcurrentHashMap());

  FlowWrapper(String projectFlowId) {
    this.project = projectFlowId
  }

  ServiceMessage start(DescriptorWrapper descriptor, SuiteDescriptorWrapper suite) {
    return started.add(descriptor.flowId) ? new ServiceMessage("flowStarted", ["flowId": descriptor.flowId, "parent": suite?.flowId ?: id]) : null
  }

  ServiceMessage finish(DescriptorWrapper descriptor) {
    return started.remove(descriptor.flowId) ? new ServiceMessage("flowFinished", ["flowId": descriptor.flowId]) : null
  }

  String getId() {
    return project
  }
}

public class SuiteDescriptorWrapper extends DescriptorWrapper {
  private static final Pattern partition = ~/^Partition \d+ .*/

  SuiteDescriptorWrapper(TestDescriptor descriptor, FlowWrapper flow, Pattern ignore) {
    super(descriptor, flow, ignore)
  }

  void start(Closure action) {
    if (ignored) return
    ServiceMessage msg = new TestSuiteStarted(descriptor.name)
    msg.setFlowId(flowId)

    action(flow.start(this, parent), msg)
  }

  void finish(Closure action) {
    if (ignored) return
    ServiceMessage msg = new TestSuiteFinished(descriptor.name)
    msg.setFlowId(flowId)

    action(flow.finish(this), msg)
  }

  boolean isIgnored() {
    if (descriptor.parent == null) return true
    if (descriptor.name.startsWith("Gradle Test Executor")) return true
    if (descriptor.name.startsWith("Gradle Test Run")) return true
    if (ignoreSuite != null) {
      return ignoreSuite.matcher(descriptor.name)
    } else {
      return descriptor.name.startsWith("Partition ") && partition.matcher(descriptor.name).matches()
    }
  }
}

public class TestDescriptorWrapper extends DescriptorWrapper {
  private final TestNameDescriptor testNameDescriptor
  private final ProjectPropertyStorage project

  TestDescriptorWrapper(TestDescriptor descriptor, TestNameDescriptor testNameDescriptor, FlowWrapper flow, ProjectPropertyStorage project, Pattern ignoreSuite) {
    super(descriptor, flow, ignoreSuite)
    this.testNameDescriptor = testNameDescriptor
    this.project = project
  }

  void start(Closure action) {
    ServiceMessage msg = new TestStarted(testName, false, null)
    msg.setFlowId(flowId)

    action(flow.start(this, parent), msg)
  }

  void finish(TestResult result, Closure action) {
    ServiceMessage msg = new TestFinished(testName, (int)(result.endTime - result.startTime))
    msg.setFlowId(flowId)

    action(flow.finish(this), msg)
  }

  boolean isIgnored() {
    className == null
  }

  void result(TestResult result, AtomicLong testCounter, Closure action) {
    switch (result?.getResultType() ?: org.gradle.api.tasks.testing.TestResult.ResultType.SUCCESS) {
      case org.gradle.api.tasks.testing.TestResult.ResultType.FAILURE:
        WrappedException exception = new WrappedException(result.getException())
        List<ServiceMessage> messages = attacheBigFailTestMessage(exception, testCounter)
        ServiceMessage failure = exception.getServiceMessage(testName)
        failure.setFlowId(flowId)
        action([*messages, failure])
        break
      case org.gradle.api.tasks.testing.TestResult.ResultType.SKIPPED:
        ServiceMessage skipped = new TestIgnored(testName, "")
        skipped.setFlowId(flowId)
        action([skipped])
        break
    };
  }

  void flush(List outputs, Closure action) {
    if (outputs == null) return
    StringBuilder stdout = new StringBuilder()
    StringBuilder stderr = new StringBuilder()

    synchronized (outputs) {
      for (oe in outputs) {
        switch (oe.destination) {
          case TestOutputEvent.Destination.StdErr:
            stderr.append(oe.message)
            break
          case TestOutputEvent.Destination.StdOut:
            stdout.append(oe.message)
            break
        }
      }

      if (stdout.length() > 0) {
        def msg = new TestStdOut(testName, stdout.toString() - ~/\r?\n\z/)
        msg.addTag(ServiceMessage.PARSE_SERVICE_MESSAGES_INSIDE_TAG)
        msg.setFlowId(flowId)
        action(msg)
      }

      if (stderr.length() > 0) {
        def msg = new TestStdErr(testName, stderr.toString() - ~/\r?\n\z/)
        msg.addTag(ServiceMessage.PARSE_SERVICE_MESSAGES_INSIDE_TAG)
        msg.setFlowId(flowId)
        action(msg)
      }
    }
  }

  private String getTestName() {
    testNameDescriptor?.getTestName(this) ?: TestNameDescriptor.DEFAULT.getTestName(this)
  }

  String getClassName() {
    return descriptor.getClassName()
  }

  String getName() {
    return descriptor.getName()
  }

  String getClassDisplayName() {
    if(descriptor.metaClass.respondsTo(descriptor, "getClassDisplayName")) {
      return descriptor.getClassDisplayName() ?: descriptor.getClassName()
    }
    return descriptor.getClassName()
  }

  String getDisplayName() {
    if(descriptor.metaClass.respondsTo(descriptor, "getDisplayName")) {
      return descriptor.getDisplayName() ?: descriptor.getName()
    }
    return descriptor.getName()
  }

  private List<ServiceMessage> attacheBigFailTestMessage(WrappedException exception, AtomicLong testCounter) {
    if(exception.small) return []

    File artifactDir = createBigStacktracesDir()
    if (artifactDir == null) {
      return []
    }
    String fileName = "${testCounter.incrementAndGet()}.log"
    File artifactPath = new File(artifactDir, fileName)

    PrintStream logFilePrint
    try {
      artifactPath.delete()
      logFilePrint = new PrintStream(new FileOutputStream(artifactPath))
      exception.th.printStackTrace(logFilePrint)
    } finally {
      logFilePrint?.close()
    }

    String artifactName = ".teamcity/gradle/${artifactDir.name}"
    def artifact = new PublishArtifacts("${artifactPath.canonicalPath} => ${artifactName}")
    artifact.setFlowId(flowId)

    ServiceMessage metadata = new ServiceMessage(ServiceMessageTypes.TEST_METADATA, [testName: testName,
                                                                                     type    : 'artifact',
                                                                                     value   : "${artifactName}/${fileName}" as String,
                                                                                     name    : 'teamcity.test.output'])
    metadata.setFlowId(flowId)
    return [artifact, metadata]
  }

  synchronized private File createBigStacktracesDir() {
    String path = null;
    if ((path = project["teamcity.build.stacktraceLogDir"]) != null) {
      return new File(path)
    }

    final String rootTmpDirectory = project[AgentRuntimeProperties.BUILD_TEMP_DIR] ?: project.getBuildDir().path
    File resultDir = new File("${rootTmpDirectory}${File.separator}.teamcity${File.separator}testFailMessages${File.separator}${System.nanoTime()}")
    if (resultDir.mkdirs()) {
      project["teamcity.build.stacktraceLogDir"] = resultDir.path
      return resultDir
    }
    return null
  }

  @Override
  boolean equals(Object obj) {
    return obj != null &&
           obj.class == TestDescriptorWrapper.class &&
           descriptor.equals(((TestDescriptorWrapper)obj).descriptor)
  }

  @Override
  int hashCode() {
    return descriptor.hashCode()
  }
}

class DescriptorWrapper {
  protected final TestDescriptor descriptor
  protected final FlowWrapper flow
  protected final Pattern ignoreSuite

  DescriptorWrapper(TestDescriptor descriptor, FlowWrapper flow, Pattern ignoreSuite) {
    this.descriptor = descriptor
    this.flow = flow
    this.ignoreSuite = ignoreSuite
  }

  protected SuiteDescriptorWrapper getParent() {
    def parent = descriptor.parent
    if (parent != null) return new SuiteDescriptorWrapper(parent, flow, ignoreSuite).with { suite -> suite.ignored ? null : suite }
    return null
  }

  protected String getFlowId() {
    return "${flow.id}-${System.identityHashCode(descriptor)}"
  }
}

public class TeamcityRerunTestsListener extends  BuildAdapter {
  Logger logger
  AtomicReference<Properties> config;
  boolean defaultOption = false;
  boolean newOption = false;

  public TeamcityRerunTestsListener(Logger log, AtomicReference<Properties> tcConfigurationParameters) {
    logger = log
    config = tcConfigurationParameters
  }

  @Override
  void projectsEvaluated(Gradle gradle) {
    defaultOption = System.getenv(GradleRunnerConstants.ENV_SUPPORT_TEST_RETRY).toBoolean()
    if (defaultOption == true) return
    def conf = config.get()
    if (conf != null && conf[GradleRunnerConstants.GRADLE_USE_TEST_RETRY_PLUGIN] == "false") return

    gradle.taskGraph.whenReady { graph ->
      for (Task task : graph.allTasks) {
        if (!TestTaskWrapper.type.isAssignableFrom(task.class)) continue
        if (!task.project.plugins.hasPlugin("org.gradle.test-retry")) continue
        def wrapper = new TestTaskWrapper(task)
        def plugin = wrapper.getExtensions()?.findByName("retry")
        if (plugin == null) continue
        if (!plugin.metaClass.respondsTo(plugin, "getMaxRetries")) continue
        def retries = plugin.getMaxRetries()
        if (!retries.metaClass.respondsTo(retries, "getOrNull")) continue
        if (retries.getOrNull() ?: 0 > 0) {
          newOption = true
          logger.lifecycle(new ServiceMessage("testRetrySupport", ["enabled": "true"]).asString())
          break
        }
      }
    }
  }

  @Override
  void buildFinished(BuildResult result) {
    if (defaultOption == true || defaultOption == newOption) return
    logger.lifecycle(new ServiceMessage("testRetrySupport", ["enabled": defaultOption.toString()]).asString())
  }
}

public class TeamcityExceptionsListener extends BuildAdapter {
  def logger

  public TeamcityExceptionsListener(Logger log) {
    logger = log
  }

  @Override
  void buildFinished(BuildResult result) {
    def failure = result.getFailure()
    if (failure != null) {
      while (!(failure instanceof org.gradle.api.tasks.TaskExecutionException) && failure != failure.getCause() && failure.getCause() != null) {
        failure = failure.getCause()
      }
      def message;
      if (failure instanceof org.gradle.api.tasks.TaskExecutionException && failure.getCause() != null) {
        message = "${failure.getMessage()} ${failure.getCause().getClass().getName()}: ${failure.getCause().getMessage()}"
      } else {
        message = "${failure.getClass().getName()}: ${failure.getMessage()}"
      }
      if (message.contains("There were failing tests") || message.contains("Compilation failed") || message.contains("Compilation error")) {
        // do not report tests and compilation failures as build problems, as they are logged separately
        return
      }
      logger.warn(new GradleBuildProblem(message).asString());
    }
  }
}

/**
 * Use WrappedException if you need to make a error message shorter
 */
class WrappedException extends Exception {
  private static final int MAX_MESSAGE_SIZE = Integer.getInteger("teamcity.gradle.stacktrace.maxLength", 18 * 1024)
  private static final int MIN_ATTACHED_MESSAGE_SIZE = Integer.getInteger("teamcity.gradle.minAttachedTestException", MAX_MESSAGE_SIZE)

  final Throwable th
  private final int maxLength
  private final String DELIMITER
  private final String message
  private final String thMessage

  /**
   * @param th original exception
   */
  WrappedException(Throwable th) {
    this(th, MAX_MESSAGE_SIZE)
  }

  /**
   * @param th     original exception
   * @param length max message length
   */
  WrappedException(Throwable th, int maxLength) {
    this.th = th ?: new Exception() {
      @Override void printStackTrace(PrintWriter printWriter) { }
      @Override void printStackTrace(PrintStream ps) { }
      @Override void printStackTrace() { }
      @Override Throwable fillInStackTrace() { this }
      @Override StackTraceElement[] getStackTrace() { new StackTraceElement[0] }
      @Override String toString() { "" }
    }

    this.maxLength = maxLength
    int size = maxLength / 1024
    DELIMITER = "***** A part of the stacktrace was cut by TeamCity build agent because the stacktrace size exceeded ${size} KB *****"
    thMessage = this.th.toString()
    message = trim(thMessage, maxLength)
  }

  private int getSize() {
    return thMessage.length()
  }

  @Override
  public String toString() {
    return message
  }

  public boolean isSmall() {
    if (MIN_ATTACHED_MESSAGE_SIZE == -1) return true
    if (MIN_ATTACHED_MESSAGE_SIZE > size) return true
    if (size <= maxLength) return true
    return false
  }

  public ServiceMessage getServiceMessage(String testName) {
    if (thMessage == "") return new TestFailed(testName, this);
    ComparisonFailureData cfd = ComparisonFailureUtil.extractComparisonFailure(th)
    if (cfd != null) {
      return new TestFailed(testName, this, trim(cfd.getActual(), maxLength), trim(cfd.getExpected(), maxLength));
    } else {
      return new TestFailed(testName, this);
    }
  }

  /**
   * Print StackTrace from the delegate object but a message from current current
   */
  @Override
  void printStackTrace(final PrintStream s) {
    Throwable exc = this;
    PrintStream stream = new PrintStream(s) {
      @Override
      void println(final Object obj) {
        super.println(th.is(obj) ? exc : obj)
      }
    }
    th.printStackTrace(stream)
  }

  /**
   * Split the message into 2 parts, if its size is large
   * @param str original message
   * @param length       max length
   * @return original message if str.length < length or split message with delimiter
   */
  private String trim(String str, int maxLength) {
    if (str == null || str.length() <= maxLength) return str

    return """${str.substring(0, (int)(maxLength / 2))} ...

${DELIMITER}

... ${str.substring(str.length() - (int)(maxLength / 2))}"""
  }
}

class TestTaskWrapper {
  final static Class type
  static {
    try {
      type = Class.forName("org.gradle.api.tasks.testing.AbstractTestTask")
    } catch (ClassNotFoundException ignore) {
      type = Test.class
    }
  }
  private final def testTask

  /**
   * Use {@link TestTaskWrapper#forAllTestTasks} to instantiate this object correctly.
   */
  private TestTaskWrapper(def testTask) { this.testTask = testTask }
  void addTestListener(def listener) { testTask.addTestListener(listener) }
  void addTestOutputListener(def listener) { testTask.addTestOutputListener(listener) }
  Project getProject() { testTask.project }
  TestTaskWrapper jvmArgs(Object... arguments) {
    if (testTask instanceof Test) {
      testTask.jvmArgs(arguments)
    }
    return this
  }

  TestTaskWrapper setTmpDirectory(String path) {
    if (testTask instanceof Test &&
        path != null && path != "") {
      testTask.systemProperty("java.io.tmpdir", path)
    }
    return this
  }

  def getExtensions() {
    if(testTask.metaClass.respondsTo(testTask, 'getExtensions')) {
      return testTask.extensions
    }
    return null
  }

  TestFilterWrapper getFilter() {
    if(testTask.metaClass.respondsTo(testTask, 'getFilter')) {
      return new TestFilterWrapper(testTask.filter)
    } else {
      return new TestFilterWrapper(null)
    }
  }

  /**
   * Creates an instance of the {@link TestTaskWrapper} for every instance of the Test in the TaskCollection.
   * Attempts to lazily evaluate the Closure action against all instances lazily if the version of Gradle supports it.
   */
  static void forAllTestTasks(TaskCollection taskCollection, Closure action) {
    if (taskCollection.metaClass.respondsTo(taskCollection, 'configureEach')) {
      // Use lazy task configuration:
      // https://docs.gradle.org/current/userguide/task_configuration_avoidance.html
      taskCollection.configureEach { task ->
        TestTaskWrapper wrapper = new TestTaskWrapper(task)
        action(wrapper)
      }
    } else {
      // Fallback
      taskCollection.all { task ->
        TestTaskWrapper wrapper = new TestTaskWrapper(task)
        action(wrapper)
      }
    }
  }
}

class TestFilterWrapper {
  final def filter
  TestFilterWrapper(def filter) {
    if (filter == null) {
      this.filter = null
    } else if (filter.metaClass.respondsTo(filter, 'excludeTest') &&
               filter.metaClass.respondsTo(filter, 'setFailOnNoMatchingTests')) {
      this.filter = filter
    } else {
      this.filter = null
    }
  }

  void setFailOnNoMatchingTests(boolean failOnNoMatchingTests) {
    filter?.setFailOnNoMatchingTests(failOnNoMatchingTests)
  }

  void excludeTest(String className, String methodName) {
    filter?.excludeTest(className, methodName)
  }

  boolean isSupported() {
    return filter != null
  }

  void updateFilters(String fileName, Logger logger) {
    if (fileName == null || fileName.trim().length() == 0 || !new File(fileName).exists()) {
      // log
      return
    }
    if (!supported) {
      // log
      return
    }

    failOnNoMatchingTests = false
    new GradleTestFilter(new File(fileName)).process { test -> excludeTest(test, null) }
  }
}

def isParallelExec = (gradle.startParameter.hasProperty("parallelThreadCount") && gradle.startParameter.parallelThreadCount != 0) ||
                     (gradle.startParameter.hasProperty("parallelProjectExecutionEnabled") && gradle.startParameter.parallelProjectExecutionEnabled);
def testOutputListenerClass = null
try {
  testOutputListenerClass = Class.forName("org.gradle.api.tasks.testing.TestOutputListener", false, getClass().getClassLoader());
} catch (ClassNotFoundException e) {
  logger.debug("Could not load TestOutputListener class. Test output will not be available")
}

final AtomicLong testCounter = new AtomicLong(0);
final AtomicReference<Properties> tcConfigurationParameters = new AtomicReference<Properties>(new Properties())

gradle.addListener(new TeamcityPropertiesListener(logger, { project ->
  // init jvm args
  final String jvmargs = (String)project.teamcity["gradle.test.jvmargs"]
  final String[] arguments = jvmargs == null ? new String[0] : jvmargs.split("\n")
  TestTaskWrapper.forAllTestTasks(project.tasks.withType(TestTaskWrapper.type)) { TestTaskWrapper task ->
    task.setTmpDirectory(project.teamcity["teamcity.build.tempDir"]).jvmArgs(arguments)
  }
  // read teamcity configuration parameters
  String tcConfigFile = project.teamcity[AgentRuntimeProperties.AGENT_CONFIGURATION_PARAMS_FILE_PROP]
  if (tcConfigFile != null && new File(tcConfigFile).exists()) {
    tcConfigurationParameters.set(TeamcityPropertiesListener.getProps(project, logger, tcConfigFile))
  }
}))

gradle.addListener(new TeamcityExceptionsListener(logger))
gradle.addListener(new TeamcityRerunTestsListener(logger, tcConfigurationParameters))
gradle.useLogger(new TeamcityTaskListener(logger, isParallelExec))
gradle.projectsEvaluated { Gradle gradle ->
  new DependencyBasedTestRun(logger).configureGradle(gradle)
  gradle.rootProject.allprojects { Project project ->
    TestTaskWrapper.forAllTestTasks(project.tasks.withType(TestTaskWrapper.type)) { TestTaskWrapper testTask ->
      Properties tcConfigParams = tcConfigurationParameters.get()
      def descriptor = TestNameDescriptor.of(tcConfigParams[GradleRunnerConstants.GRADLE_TEST_NAME_FORMAT])

      def testListener = new TeamcityTestListener(logger, testTask, isParallelExec, project, testCounter, descriptor, tcConfigParams[GradleRunnerConstants.GRADLE_IGNORED_SUITE_FORMAT])
      testTask.addTestListener(testListener.testListenerDelegate as TestListener)
      if (testOutputListenerClass != null) {
        testTask.addTestOutputListener(testListener.testOutputDelegate.asType(testOutputListenerClass))
        testListener.skipStdOut = Boolean.valueOf(System.properties["teamcity.ignoreTestStdOut"])
        testListener.skipStdErr = Boolean.valueOf(System.properties["teamcity.ignoreTestStdErr"])
      }
      // add executable tests
      testTask.filter.updateFilters(System.getenv(GradleRunnerConstants.TEAMCITY_PARALLEL_TESTS_ARTIFACT_PATH), logger)
    }
  }

  gradle.rootProject.allprojects.each { project ->
    project.getTasks().findByName("junitPlatformTest")?.outputs?.files?.each { file ->
      def message = new ServiceMessage("importData", ["type": "junit", "path": "$file.absolutePath/*.xml".toString()])
      println(message.asString())
    }
  }
}